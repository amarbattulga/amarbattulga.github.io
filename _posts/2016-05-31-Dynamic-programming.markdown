---
layout: post
title:  "Динамик програмчлал"
date:   2016-03-07 16:24:00
categories: algorithm
---
Dynamic programming - Үүнээс цааш товчилж **DP** гэх болно

DP-г сурахын тулд бодлогийн төлөвийг тодорхойлох мөн одоогийн бодлого болон
дэд бодлого хоорондох уялдаа холбоо болон шилжилтүүдийг сайн шинжиж сурах хэрэгтэй юм.

Хэрэв бодлого:

1. Хэдэн янзын боломж байгаа вэ?
2. Үүнийг ихэсгэ?
3. Үүнийг багасга?

Дээрх үгсээс бүрдсэн байвал тухайн бодлого нь **DP** бодлого байх магадлал өндөр юм.

Гэх мэтчилэн эхлээд бодлогийг **DP** ашиглаж бодож болох эсэхийг мэдэх юм.
Энэ тийм ч амар ажил биш ба их олон бодлого бодсоны дараа өөрөө суудаг чадвар юм. 

Тиймээс уг аргийг жишээ бодлого ашиглан сурцгаая.

# Жишээ бодлого
Доорхи бодлогоор жишээ авч DP талаар дэлгэрэнгүй судалцгаая

[UVA 11450 - Wedding shopping](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2445){:target="_blank"}

#### - Дээрх бодлогийн хураангүй үгүйлбэр

Өгөгдсөн тодорхой тооны хувцаснуудын ( 3 өөр загварын өмд, 2 цамц, 10 подвалк гэх мэт ) тус бүрийнх нь үнэ нь өгөгджээ.

Бидний түрүүвчинд **M** төгрөг байгаа ба бид бүх хувцаснуудас яг нэг, нэгийг аваад хамгийн ихдээ хэдэн төгрөг үрж чадах вэ? *(Мэдээж мөнгөн дүн M-с хэтэрч болохгүй)*

G - Хувцасны тоо **G <= 20**

K - Нэг хувцасны загварынх нь тоо **K <= 20**

M - Мөнгөний хэмжээ **M <= 200**


### Бодолт 1: Шунахай бодолт ( [**Wrong answer**](#){:style="color:red"} )
**Санаа:** хувцас бүрээс хамгийн үнэтэйг нь авах:

### Бодолт 2: Бүрэн хайлт **( Time limit exceeded )**
20^20

### Бодолт 3: Дээрээс доош DP ( [**Accepted**](#){:style="color:green"} )
Бид энэ бодлогийг DP ашиглаж бодож болж байна. Учир уг бодлого DP бодлогонд байдаг доорх үндсэн 2 нөхцөлийг хангажээ.

1. Бодлогийг биесээсээ хамааралгүй хэсгүүдэд хувааж болохуйц.
2. Дэд бодлогууд хоорондоо давхацаж байна. **Энэ нь динамик бодлогийн үндсэн шинж гэж хэлж болох юм.**

{% highlight cpp %}
// Бичиглэлийн алдаа байз болзошгүй

#include<bits/stdc++.h>

using namespace std;

int G, M;
int memo[200][200];
vector< vector<int> > gList;

// Оролт унших
void init(){
     cin >> M >> G;

     gList.resize(G);

     for (int i=0; i<G; i++){
     	 int K;
	 cin >> K;
	 
	 gList[i].resize(K);
	 for (int j=0; j<K; k++)
	     cin >> gList[i][j];
     }

     // Set initial value
     memset(memo, -1, sizeof(memo));
}

int shop(int money, int currentG){
    if (money < 0)
       return -1e6;

    if (currentG == G)
       return M - money;

    if ( memo[money][currentG] != -1 )
       return memo[money][currentG];

    int ans = -1e6; // -1e6 == 1000000
    for (int i=0; i<gList[currentG].size(); i++)
    	ans = max(ans, shop(money - gList[currentG][i], currentG + 1));

    memo[money][currenG] = ans;
    return memo[money][currentG]
}

int main(){
    init();
    cout << shop(M, G-1);
}
{% endhighlight %}